# -*- coding: utf-8 -*-
"""Untitled35.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aypLge3l4bpp2PTX1snKzu-52ENbLS7N
"""

import streamlit as st
import pandas as pd
import numpy as np
import xgboost as xgb
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error
import plotly.express as px
import plotly.graph_objects as go

# --- CONFIGURACIÃ“N DE PÃGINA ---
st.set_page_config(page_title="App MetalÃºrgica Pro", layout="wide")
st.title("ğŸ­ Inteligencia de Procesos MetalÃºrgicos")

# --- CARGA DE DATOS ---
st.sidebar.header("ğŸ“‚ Carga de Archivos")
archivo = st.sidebar.file_uploader("Subir dataset (CSV o Excel)", type=["csv", "xlsx"])

if archivo:
    df = pd.read_csv(archivo) if archivo.name.endswith('.csv') else pd.read_excel(archivo)
    df.columns = df.columns.astype(str).str.strip()
    for col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='ignore')

    num_cols = df.select_dtypes(include=[np.number]).columns.tolist()

    tab_vista, tab_limpieza, tab_modelo, tab_analisis, tab_simulador = st.tabs([
        "ğŸ‘ï¸ 1. Vista Previa", "ğŸ§¹ 2. Limpieza", "ğŸ› ï¸ 3. Entrenamiento", "ğŸ“Š 4. Explorador X-Y", "ğŸ¯ 5. Panel de Control"
    ])

    with tab_vista:
        st.subheader("ğŸ“Š AnÃ¡lisis Descriptivo")
        col_v1, col_v2 = st.columns([2, 1])
        with col_v1:
            st.write("**Primeras 50 filas:**")
            st.dataframe(df.head(50), use_container_width=True)
        with col_v2:
            st.write("**Resumen EstadÃ­stico:**")
            st.dataframe(df.describe().T, use_container_width=True)

    with tab_limpieza:
        st.subheader("ğŸ§¹ GestiÃ³n Manual de Outliers")
        col_out = st.selectbox("Selecciona columna para detectar outliers (IQR):", num_cols)
        Q1, Q3 = df[col_out].quantile(0.25), df[col_out].quantile(0.75)
        IQR = Q3 - Q1
        outliers = df[(df[col_out] < Q1 - 1.5*IQR) | (df[col_out] > Q3 + 1.5*IQR)].copy()

        if not outliers.empty:
            st.warning(f"Se detectaron {len(outliers)} outliers en {col_out}")
            outliers['ELIMINAR'] = True
            edited = st.data_editor(outliers, use_container_width=True, hide_index=True)
            df_limpio = df.drop(edited[edited['ELIMINAR'] == True].index)
            st.success(f"Muestras finales tras limpieza: {len(df_limpio)}")
        else:
            st.success("No se detectaron outliers automÃ¡ticos.")
            df_limpio = df.copy()

    with tab_modelo:
        st.subheader("ğŸ› ï¸ ConfiguraciÃ³n del Modelo")
        c1, c2 = st.columns(2)
        target = c1.selectbox("ğŸ¯ Variable Objetivo (Y):", num_cols)
        features = c2.multiselect("ğŸ” Variables de Entrada (X):", [c for c in num_cols if c != target])

        if st.button("ğŸš€ Entrenar Modelo de Planta", use_container_width=True):
            if not features: st.error("Selecciona al menos una variable.")
            else:
                data = df_limpio[[target] + features].dropna()
                X, y = data[features], data[target]
                X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

                model = xgb.XGBRegressor(n_estimators=150, max_depth=5, learning_rate=0.06)
                model.fit(X_train, y_train)
                y_pred = model.predict(X_test)

                st.markdown("### ğŸ›¡ï¸ Reporte TÃ©cnico")
                r2, mae, rmse = r2_score(y_test, y_pred), mean_absolute_error(y_test, y_pred), np.sqrt(mean_squared_error(y_test, y_pred))
                bias = np.mean(y_pred - y_test)

                m1, m2, m3, m4 = st.columns(4)
                m1.metric("RÂ² PrecisiÃ³n", f"{r2:.4f}")
                m2.metric("MAE", f"{mae:.4f}")
                m3.metric("RMSE", f"{rmse:.4f}")
                m4.metric("Bias (Sesgo)", f"{bias:.4f}")

                res_df = X_test.copy()
                res_df['REAL'], res_df['PREDICCION'] = y_test.values, y_pred
                st.session_state.update({'mod': model, 'feat': features, 'targ': target, 'db': df_limpio, 'res': res_df})

    with tab_analisis:
        if 'res' in st.session_state:
            st.subheader("ğŸ“Š Explorador de Correlaciones")
            cx, cy, cc = st.columns(3)
            ex = cx.selectbox("Eje X:", st.session_state.res.columns)
            ey = cy.selectbox("Eje Y:", st.session_state.res.columns, index=len(st.session_state.res.columns)-1)
            ec = cc.selectbox("Color por:", st.session_state.res.columns)
            fig_sc = px.scatter(st.session_state.res, x=ex, y=ey, color=ec, trendline="ols", template="plotly_white")
            st.plotly_chart(fig_sc, use_container_width=True)

    with tab_simulador:
        if 'mod' in st.session_state:
            st.subheader("ğŸ¯ Simulador y Sensibilidad")
            col_sl, col_ga = st.columns([1, 2])
            with col_sl:
                inputs = {}
                for f in st.session_state.feat:
                    v_min, v_max = float(st.session_state.db[f].min()), float(st.session_state.db[f].max())
                    v_avg = float(st.session_state.db[f].mean())
                    inputs[f] = st.slider(f, v_min, v_max, v_avg)

            pred = st.session_state.mod.predict(pd.DataFrame([inputs]))[0]
            with col_ga:
                st.metric(f"PREDICCIÃ“N DE {st.session_state.targ}", f"{pred:.2f}")
                sens = {}
                for f in st.session_state.feat:
                    df_plus = pd.DataFrame([inputs])
                    rango = st.session_state.db[f].max() - st.session_state.db[f].min()
                    df_plus[f] += rango * 0.05
                    sens[f] = st.session_state.mod.predict(df_plus)[0] - pred
                sens_df = pd.Series(sens).sort_values()
                fig_sens = px.bar(x=sens_df.values, y=sens_df.index, orientation='h', title="Sensibilidad Local", color=sens_df.values, color_continuous_scale="RdYlGn")
                st.plotly_chart(fig_sens, use_container_width=True)
else:
    st.info("Sube un archivo para comenzar.")